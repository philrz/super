script: |
  echo === debug
  super compile -C -O 'from /dev/null | debug a | values b'
  echo === distinct
  super compile -C -O 'from /dev/null | distinct a | values b'
  echo === fork into hash join
  super compile -C -O -dynamic 'fork ( from /dev/null ) ( from /dev/zero ) | join on right.a=left.b | values left.c,right.d'
  echo === fork into nested loop join
  super compile -C -O -dynamic 'fork ( from /dev/null ) ( from /dev/zero ) | join on right.a>left.b | values left.c,right.d'
  echo === hash join
  super compile -C -O -dynamic "from /dev/null | join (from /dev/zero) on left.a=right.b | values left.c,right.d"
  echo === nested loop join
  super compile -C -O -dynamic "from /dev/null | join (from /dev/zero) on left.a>right.b | values left.c,right.d"
  echo === switch into hash join
  super compile -C -O 'from /dev/null | switch a case b ( put x:=c ) case d ( put x:=e ) | join on left.f=right.g | values left.h,right.i'
  echo === switch into nested loop join
  super compile -C -O 'from /dev/null | switch a case b ( put x:=c ) case d ( put x:=e ) | join on left.f>right.g | values left.h,right.i'
  echo === where
  super compile -C -O "from /dev/null | a==1 or e==2 | values c, b, d"
  echo ===
  export SUPER_DB=test
  super db init -q
  super db create -q -orderby ts pool-ts
  super db compile -C -O "from 'pool-ts' | x=='hello' or x==1.0 | values a" | sed -e 's/lister .*/lister/' -e 's/seqscan .*field/seqscan field/'
  echo ===
  super db compile -C -O "from 'pool-ts' | x > 1 and y <= 1.0" | sed -e 's/lister .*/lister/' -e 's/seqscan .*filter/seqscan filter/'
  echo ===
  super db compile -C -O "from 'pool-ts' | x=='hello' or x!=1.0" | sed -e 's/lister .*/lister/' -e 's/seqscan .*filter/seqscan filter/'
  echo ===
  super db compile -C -O "from 'pool-ts' | x=='hello' or !(y==2 or y==3)" | sed -e 's/lister .*/lister/' -e 's/seqscan .*filter/seqscan filter/'
  echo ===
  super db compile -C -O "from 'pool-ts' | ts >= 0 and ts <= 2" | sed -e 's/lister .*pruner/lister pruner/' -e 's/seqscan .*pruner/seqscan pruner/'
  echo ===
  super db compile -C -O "from 'pool-ts' | ts >= 0 and ts <= 2 and x=='hello'"| sed -e 's/lister .*pruner/lister pruner/' -e 's/seqscan .*pruner/seqscan pruner/'

outputs:
  - name: stdout
    data: |
      === debug
      file /dev/null fields a,b
      | mirror
        (
          values a
          | output debug
        )
        (
          values b
          | output main
        )
      === distinct
      file /dev/null unordered fields a,b
      | distinct a
      | values b
      | output main
      === fork into hash join
      fork
        (
          file /dev/null unordered fields b,c
        )
        (
          file /dev/zero unordered fields a,d
        )
      | inner hashjoin as {left,right} on b==a
      | values left.c, right.d
      | output main
      === fork into nested loop join
      fork
        (
          file /dev/null unordered fields b,c
        )
        (
          file /dev/zero unordered fields a,d
        )
      | inner join as {left,right} on right.a>left.b
      | values left.c, right.d
      | output main
      === hash join
      fork
        (
          file /dev/null unordered fields a,c
        )
        (
          file /dev/zero unordered fields b,d
        )
      | inner hashjoin as {left,right} on a==b
      | values left.c, right.d
      | output main
      === nested loop join
      fork
        (
          file /dev/null unordered fields a,c
        )
        (
          file /dev/zero unordered fields b,d
        )
      | inner join as {left,right} on left.a>right.b
      | values left.c, right.d
      | output main
      === switch into hash join
      file /dev/null unordered fields a,b,c,d,e,f,g,h,i
      | switch a
        case b (
          put x:=c
        )
        case d (
          put x:=e
        )
      | inner hashjoin as {left,right} on f==g
      | values left.h, right.i
      | output main
      === switch into nested loop join
      file /dev/null unordered fields a,b,c,d,e,f,g,h,i
      | switch a
        case b (
          put x:=c
        )
        case d (
          put x:=e
        )
      | inner join as {left,right} on left.f>right.g
      | values left.h, right.i
      | output main
      === where
      file /dev/null fields a,b,c,d,e filter (a==1 or e==2)
      | values c, b, d
      | output main
      ===
      lister
      | slicer
      | seqscan fields a,x filter (x=="hello" or x==1.)
      | values a
      | output main
      ===
      lister
      | slicer
      | seqscan filter (x>1 and y<=1.)
      | output main
      ===
      lister
      | slicer
      | seqscan filter (x=="hello" or x!=1.)
      | output main
      ===
      lister
      | slicer
      | seqscan filter (x=="hello" or !(y==2 or y==3))
      | output main
      ===
      lister pruner (compare(0, max, true)>0 or compare(2, min, true)<0)
      | slicer
      | seqscan pruner (compare(0, max, true)>0 or compare(2, min, true)<0) filter (ts>=0 and ts<=2)
      | output main
      ===
      lister pruner (compare(0, max, true)>0 or compare(2, min, true)<0)
      | slicer
      | seqscan pruner (compare(0, max, true)>0 or compare(2, min, true)<0) filter (ts>=0 and ts<=2 and x=="hello")
      | output main
