// Code generated by genarithfuncs.go. DO NOT EDIT.

package expr

import (
	"github.com/brimdata/super"
	"github.com/brimdata/super/vector"
	"github.com/brimdata/super/vector/bitvec"
)

func arithAddIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddIntConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddIntConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	val := super.NewInt(lhs.Type(), lconst+rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithAddUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddUintConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddUintConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	val := super.NewUint(lhs.Type(), lconst+rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithAddFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddFloatConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	val := super.NewFloat(lhs.Type(), lconst+rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithSubIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubIntConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubIntConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	val := super.NewInt(lhs.Type(), lconst-rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithSubUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubUintConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubUintConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	val := super.NewUint(lhs.Type(), lconst-rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithSubFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubFloatConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	val := super.NewFloat(lhs.Type(), lconst-rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithMulIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulIntConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulIntConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	val := super.NewInt(lhs.Type(), lconst*rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithMulUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulUintConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulUintConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	val := super.NewUint(lhs.Type(), lconst*rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithMulFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulFloatConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	val := super.NewFloat(lhs.Type(), lconst*rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithDivIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivIntConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivIntConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	val := super.NewInt(lhs.Type(), lconst/rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithDivUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivUintConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivUintConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	val := super.NewUint(lhs.Type(), lconst/rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithDivFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivFloatConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsFloat()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsFloat()
	val := super.NewFloat(lhs.Type(), lconst/rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithModIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(k))
	}
	return out
}

func arithModIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % rconst)
	}
	return out
}

func arithModIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModIntConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(k))
	}
	return out
}

func arithModIntConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsInt()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsInt()
	val := super.NewInt(lhs.Type(), lconst%rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

func arithModUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(k))
	}
	return out
}

func arithModUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % rconst)
	}
	return out
}

func arithModUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModUintConstFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(k))
	}
	return out
}

func arithModUintConstDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintConstView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(lhs.Type(), n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintConstConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Const)
	lconst, _ := l.AsUint()
	r := rhs.(*vector.Const)
	rconst, _ := r.AsUint()
	val := super.NewUint(lhs.Type(), lconst%rconst)
	return vector.NewConst(val, lhs.Len(), bitvec.Zero)
}

var arithFuncs = map[int]func(vector.Any, vector.Any) vector.Any{
	16:   arithAddIntFlatFlat,
	20:   arithAddIntFlatDict,
	24:   arithAddIntFlatView,
	28:   arithAddIntFlatConst,
	17:   arithAddIntDictFlat,
	21:   arithAddIntDictDict,
	25:   arithAddIntDictView,
	29:   arithAddIntDictConst,
	18:   arithAddIntViewFlat,
	22:   arithAddIntViewDict,
	26:   arithAddIntViewView,
	30:   arithAddIntViewConst,
	19:   arithAddIntConstFlat,
	23:   arithAddIntConstDict,
	27:   arithAddIntConstView,
	31:   arithAddIntConstConst,
	32:   arithAddUintFlatFlat,
	36:   arithAddUintFlatDict,
	40:   arithAddUintFlatView,
	44:   arithAddUintFlatConst,
	33:   arithAddUintDictFlat,
	37:   arithAddUintDictDict,
	41:   arithAddUintDictView,
	45:   arithAddUintDictConst,
	34:   arithAddUintViewFlat,
	38:   arithAddUintViewDict,
	42:   arithAddUintViewView,
	46:   arithAddUintViewConst,
	35:   arithAddUintConstFlat,
	39:   arithAddUintConstDict,
	43:   arithAddUintConstView,
	47:   arithAddUintConstConst,
	48:   arithAddFloatFlatFlat,
	52:   arithAddFloatFlatDict,
	56:   arithAddFloatFlatView,
	60:   arithAddFloatFlatConst,
	49:   arithAddFloatDictFlat,
	53:   arithAddFloatDictDict,
	57:   arithAddFloatDictView,
	61:   arithAddFloatDictConst,
	50:   arithAddFloatViewFlat,
	54:   arithAddFloatViewDict,
	58:   arithAddFloatViewView,
	62:   arithAddFloatViewConst,
	51:   arithAddFloatConstFlat,
	55:   arithAddFloatConstDict,
	59:   arithAddFloatConstView,
	63:   arithAddFloatConstConst,
	272:  arithSubIntFlatFlat,
	276:  arithSubIntFlatDict,
	280:  arithSubIntFlatView,
	284:  arithSubIntFlatConst,
	273:  arithSubIntDictFlat,
	277:  arithSubIntDictDict,
	281:  arithSubIntDictView,
	285:  arithSubIntDictConst,
	274:  arithSubIntViewFlat,
	278:  arithSubIntViewDict,
	282:  arithSubIntViewView,
	286:  arithSubIntViewConst,
	275:  arithSubIntConstFlat,
	279:  arithSubIntConstDict,
	283:  arithSubIntConstView,
	287:  arithSubIntConstConst,
	288:  arithSubUintFlatFlat,
	292:  arithSubUintFlatDict,
	296:  arithSubUintFlatView,
	300:  arithSubUintFlatConst,
	289:  arithSubUintDictFlat,
	293:  arithSubUintDictDict,
	297:  arithSubUintDictView,
	301:  arithSubUintDictConst,
	290:  arithSubUintViewFlat,
	294:  arithSubUintViewDict,
	298:  arithSubUintViewView,
	302:  arithSubUintViewConst,
	291:  arithSubUintConstFlat,
	295:  arithSubUintConstDict,
	299:  arithSubUintConstView,
	303:  arithSubUintConstConst,
	304:  arithSubFloatFlatFlat,
	308:  arithSubFloatFlatDict,
	312:  arithSubFloatFlatView,
	316:  arithSubFloatFlatConst,
	305:  arithSubFloatDictFlat,
	309:  arithSubFloatDictDict,
	313:  arithSubFloatDictView,
	317:  arithSubFloatDictConst,
	306:  arithSubFloatViewFlat,
	310:  arithSubFloatViewDict,
	314:  arithSubFloatViewView,
	318:  arithSubFloatViewConst,
	307:  arithSubFloatConstFlat,
	311:  arithSubFloatConstDict,
	315:  arithSubFloatConstView,
	319:  arithSubFloatConstConst,
	528:  arithMulIntFlatFlat,
	532:  arithMulIntFlatDict,
	536:  arithMulIntFlatView,
	540:  arithMulIntFlatConst,
	529:  arithMulIntDictFlat,
	533:  arithMulIntDictDict,
	537:  arithMulIntDictView,
	541:  arithMulIntDictConst,
	530:  arithMulIntViewFlat,
	534:  arithMulIntViewDict,
	538:  arithMulIntViewView,
	542:  arithMulIntViewConst,
	531:  arithMulIntConstFlat,
	535:  arithMulIntConstDict,
	539:  arithMulIntConstView,
	543:  arithMulIntConstConst,
	544:  arithMulUintFlatFlat,
	548:  arithMulUintFlatDict,
	552:  arithMulUintFlatView,
	556:  arithMulUintFlatConst,
	545:  arithMulUintDictFlat,
	549:  arithMulUintDictDict,
	553:  arithMulUintDictView,
	557:  arithMulUintDictConst,
	546:  arithMulUintViewFlat,
	550:  arithMulUintViewDict,
	554:  arithMulUintViewView,
	558:  arithMulUintViewConst,
	547:  arithMulUintConstFlat,
	551:  arithMulUintConstDict,
	555:  arithMulUintConstView,
	559:  arithMulUintConstConst,
	560:  arithMulFloatFlatFlat,
	564:  arithMulFloatFlatDict,
	568:  arithMulFloatFlatView,
	572:  arithMulFloatFlatConst,
	561:  arithMulFloatDictFlat,
	565:  arithMulFloatDictDict,
	569:  arithMulFloatDictView,
	573:  arithMulFloatDictConst,
	562:  arithMulFloatViewFlat,
	566:  arithMulFloatViewDict,
	570:  arithMulFloatViewView,
	574:  arithMulFloatViewConst,
	563:  arithMulFloatConstFlat,
	567:  arithMulFloatConstDict,
	571:  arithMulFloatConstView,
	575:  arithMulFloatConstConst,
	784:  arithDivIntFlatFlat,
	788:  arithDivIntFlatDict,
	792:  arithDivIntFlatView,
	796:  arithDivIntFlatConst,
	785:  arithDivIntDictFlat,
	789:  arithDivIntDictDict,
	793:  arithDivIntDictView,
	797:  arithDivIntDictConst,
	786:  arithDivIntViewFlat,
	790:  arithDivIntViewDict,
	794:  arithDivIntViewView,
	798:  arithDivIntViewConst,
	787:  arithDivIntConstFlat,
	791:  arithDivIntConstDict,
	795:  arithDivIntConstView,
	799:  arithDivIntConstConst,
	800:  arithDivUintFlatFlat,
	804:  arithDivUintFlatDict,
	808:  arithDivUintFlatView,
	812:  arithDivUintFlatConst,
	801:  arithDivUintDictFlat,
	805:  arithDivUintDictDict,
	809:  arithDivUintDictView,
	813:  arithDivUintDictConst,
	802:  arithDivUintViewFlat,
	806:  arithDivUintViewDict,
	810:  arithDivUintViewView,
	814:  arithDivUintViewConst,
	803:  arithDivUintConstFlat,
	807:  arithDivUintConstDict,
	811:  arithDivUintConstView,
	815:  arithDivUintConstConst,
	816:  arithDivFloatFlatFlat,
	820:  arithDivFloatFlatDict,
	824:  arithDivFloatFlatView,
	828:  arithDivFloatFlatConst,
	817:  arithDivFloatDictFlat,
	821:  arithDivFloatDictDict,
	825:  arithDivFloatDictView,
	829:  arithDivFloatDictConst,
	818:  arithDivFloatViewFlat,
	822:  arithDivFloatViewDict,
	826:  arithDivFloatViewView,
	830:  arithDivFloatViewConst,
	819:  arithDivFloatConstFlat,
	823:  arithDivFloatConstDict,
	827:  arithDivFloatConstView,
	831:  arithDivFloatConstConst,
	1040: arithModIntFlatFlat,
	1044: arithModIntFlatDict,
	1048: arithModIntFlatView,
	1052: arithModIntFlatConst,
	1041: arithModIntDictFlat,
	1045: arithModIntDictDict,
	1049: arithModIntDictView,
	1053: arithModIntDictConst,
	1042: arithModIntViewFlat,
	1046: arithModIntViewDict,
	1050: arithModIntViewView,
	1054: arithModIntViewConst,
	1043: arithModIntConstFlat,
	1047: arithModIntConstDict,
	1051: arithModIntConstView,
	1055: arithModIntConstConst,
	1056: arithModUintFlatFlat,
	1060: arithModUintFlatDict,
	1064: arithModUintFlatView,
	1068: arithModUintFlatConst,
	1057: arithModUintDictFlat,
	1061: arithModUintDictDict,
	1065: arithModUintDictView,
	1069: arithModUintDictConst,
	1058: arithModUintViewFlat,
	1062: arithModUintViewDict,
	1066: arithModUintViewView,
	1070: arithModUintViewConst,
	1059: arithModUintConstFlat,
	1063: arithModUintConstDict,
	1067: arithModUintConstView,
	1071: arithModUintConstConst,
}
